package xlog

import (
	"context"
	"fmt"
)

// The ctxLogger type embeds the Logger interface and adds context, entries, and context handle fields.
type ctxLogger struct {
	Logger
	ctx       context.Context
	entries   map[string]any
	ctxHandle CtxHandle
}

// WithContext creates a new logger with the provided context and context handle.
// If handles is not provided, the default context handle is used.
func WithContext(logger Logger, ctx context.Context, handles ...CtxHandle) Logger {
	var handle CtxHandle
	if len(handles) > 0 {
		handle = handles[0]
	} else {
		handle = getDefCtxHandle()
	}
	return ctxLogger{
		Logger:    logger,
		ctx:       ctx,
		ctxHandle: handle,
	}
}

// WithEntries creates a new logger with the provided entries and an empty context.
func WithEntries(logger Logger, entries map[string]any) Logger {
	return ctxLogger{
		Logger:    logger,
		ctx:       context.Background(),
		entries:   entries,
		ctxHandle: emptyHandle,
	}
}

func (c ctxLogger) Log(content any, opts ...LogOption) {
	opts = append(opts, WithCallerSkipOne, WithFields(c.buildFields()...))
	c.Logger.Log(content, opts...)
}

func (c ctxLogger) Fatal(a ...any) {
	if c.IsEnabled(FATAL) {
		c.Logger.Log(fmt.Sprint(a...), withFatal, WithCallerSkipOne, WithFields(c.buildFields()...))
	}
}

func (c ctxLogger) Fatalf(format string, a ...any) {
	if c.IsEnabled(FATAL) {
		c.Logger.Log(fmt.Sprintf(format, a...), withFatal, WithCallerSkipOne, WithFields(c.buildFields()...))
	}
}

func (c ctxLogger) Fatalw(msg string, fields ...Field) {
	if c.IsEnabled(FATAL) {
		c.Logger.Log(msg, withFatal, WithCallerSkipOne, WithFields(c.buildFields(fields...)...))
	}
}

func (c ctxLogger) Error(a ...any) {
	if c.IsEnabled(ERROR) {
		c.Logger.Log(fmt.Sprint(a...), withError, WithCallerSkipOne, WithFields(c.buildFields()...))
	}
}

func (c ctxLogger) Errorf(format string, a ...any) {
	if c.IsEnabled(ERROR) {
		c.Logger.Log(fmt.Sprintf(format, a...), withError, WithCallerSkipOne, WithFields(c.buildFields()...))
	}
}

func (c ctxLogger) Errorw(msg string, fields ...Field) {
	if c.IsEnabled(ERROR) {
		c.Logger.Log(msg, withError, WithCallerSkipOne, WithFields(c.buildFields(fields...)...))
	}
}

func (c ctxLogger) Warn(a ...any) {
	if c.IsEnabled(WARN) {
		c.Logger.Log(fmt.Sprint(a...), withWarn, WithCallerSkipOne, WithFields(c.buildFields()...))
	}
}

func (c ctxLogger) Warnf(format string, a ...any) {
	if c.IsEnabled(WARN) {
		c.Logger.Log(fmt.Sprintf(format, a...), withWarn, WithCallerSkipOne, WithFields(c.buildFields()...))
	}
}

func (c ctxLogger) Warnw(msg string, fields ...Field) {
	if c.IsEnabled(WARN) {
		c.Logger.Log(msg, withWarn, WithCallerSkipOne, WithFields(c.buildFields(fields...)...))
	}
}

func (c ctxLogger) Info(a ...any) {
	if c.IsEnabled(INFO) {
		c.Logger.Log(fmt.Sprint(a...), withInfo, WithCallerSkipOne, WithFields(c.buildFields()...))
	}
}

func (c ctxLogger) Infof(format string, a ...any) {
	if c.IsEnabled(INFO) {
		c.Logger.Log(fmt.Sprintf(format, a...), withInfo, WithCallerSkipOne, WithFields(c.buildFields()...))
	}
}

func (c ctxLogger) Infow(msg string, fields ...Field) {
	if c.IsEnabled(INFO) {
		c.Logger.Log(msg, withInfo, WithCallerSkipOne, WithFields(c.buildFields(fields...)...))
	}
}

func (c ctxLogger) Debug(a ...any) {
	if c.IsEnabled(DEBUG) {
		c.Logger.Log(fmt.Sprint(a...), withDebug, WithCallerSkipOne, WithFields(c.buildFields()...))
	}
}

func (c ctxLogger) Debugf(format string, a ...any) {
	if c.IsEnabled(DEBUG) {
		c.Logger.Log(fmt.Sprintf(format, a...), withDebug, WithCallerSkipOne, WithFields(c.buildFields()...))
	}
}

func (c ctxLogger) Debugw(msg string, fields ...Field) {
	if c.IsEnabled(DEBUG) {
		c.Logger.Log(msg, withDebug, WithCallerSkipOne, WithFields(c.buildFields(fields...)...))
	}
}

// buildFields builds the final list of fields to be logged by appending
// the fields generated by the CtxHandle and the additional entries
// provided during context creation, to the fields passed as argument.
// If there are no additional entries, only the fields generated by the
// CtxHandle are appended. If there are additional entries, they are
// appended to the fields generated by the CtxHandle.
func (c ctxLogger) buildFields(fields ...Field) []Field {
	fields = append(fields, c.ctxHandle(c.ctx)...)
	if len(c.entries) > 0 {
		for key, entry := range c.entries {
			fields = append(fields, Field{Key: key, Value: entry})
		}
	}
	return fields
}
